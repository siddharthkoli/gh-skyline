package stl

import (
	"encoding/binary"
	"os"
	"path/filepath"
	"testing"

	"github.com/github/gh-skyline/types"
)

// Helper function to verify STL file header
func verifySTLHeader(t *testing.T, file *os.File) {
	t.Helper()
	headerBytes := make([]byte, 80)
	if _, err := file.Read(headerBytes); err != nil {
		t.Fatalf("Failed to read STL header: %v", err)
	}
	expectedHeaderText := "Generated by GitHub Contributions Skyline Generator"
	if string(headerBytes[:len(expectedHeaderText)]) != expectedHeaderText {
		t.Errorf("Incorrect STL header content.\nGot: %s\nWant: %s",
			string(headerBytes[:len(expectedHeaderText)]), expectedHeaderText)
	}
}

// Helper function to verify triangle count
func verifyTriangleCount(t *testing.T, file *os.File, expected uint32) {
	t.Helper()
	var storedTriangleCount uint32
	if err := binary.Read(file, binary.LittleEndian, &storedTriangleCount); err != nil {
		t.Fatalf("Failed to read triangle count: %v", err)
	}
	if storedTriangleCount != expected {
		t.Errorf("Incorrect triangle count in STL file. Got: %d, Want: %d", storedTriangleCount, expected)
	}
}

// Test case for basic STL file generation
func testBasicSTLGeneration(t *testing.T) {
	testDir := t.TempDir()
	testFilePath := filepath.Join(testDir, "test.stl")

	sampleTriangles := []types.Triangle{
		{
			Normal: types.Point3D{X: 0, Y: 0, Z: 1},
			V1:     types.Point3D{X: 0, Y: 0, Z: 0},
			V2:     types.Point3D{X: 1, Y: 0, Z: 0},
			V3:     types.Point3D{X: 0, Y: 1, Z: 0},
		},
	}

	if err := WriteSTLBinary(testFilePath, sampleTriangles); err != nil {
		t.Fatalf("Failed to write STL file: %v", err)
	}

	stlFile, err := os.Open(testFilePath)
	if err != nil {
		t.Fatalf("Cannot open generated STL file: %v", err)
	}
	defer func() {
		if err := stlFile.Close(); err != nil {
			t.Fatalf("Failed to close STL file: %v", err)
		}
	}()

	verifySTLHeader(t, stlFile)
	verifyTriangleCount(t, stlFile, 1)

	var stlTriangle struct {
		Normal    [3]float32
		Vertex1   [3]float32
		Vertex2   [3]float32
		Vertex3   [3]float32
		Attribute uint16
	}
	if err := binary.Read(stlFile, binary.LittleEndian, &stlTriangle); err != nil {
		t.Fatalf("Failed to read triangle geometry data: %v", err)
	}

	if stlTriangle.Normal[2] != 1 || stlTriangle.Vertex2[0] != 1 || stlTriangle.Vertex3[1] != 1 {
		t.Error("Triangle geometry data in STL file does not match input")
	}
}

// Test case for invalid file path
func testInvalidFilePath(t *testing.T) {
	err := WriteSTLBinary("/nonexistent/path/file.stl", []types.Triangle{})
	if err == nil {
		t.Error("Expected error for invalid file path, but got none")
	}
}

// Test case for empty triangle list
func testEmptyTriangleList(t *testing.T) {
	testDir := t.TempDir()
	emptyTestPath := filepath.Join(testDir, "empty.stl")

	if err := WriteSTLBinary(emptyTestPath, []types.Triangle{}); err != nil {
		t.Fatalf("Failed to write STL with empty triangle list: %v", err)
	}

	stlFile, err := os.Open(emptyTestPath)
	if err != nil {
		t.Fatalf("Cannot open generated STL file: %v", err)
	}
	defer func() {
		if err := stlFile.Close(); err != nil {
			t.Fatalf("Failed to close STL file: %v", err)
		}
	}()

	if _, err := stlFile.Seek(80, 0); err != nil {
		t.Fatalf("Failed to seek past header: %v", err)
	}
	verifyTriangleCount(t, stlFile, 0)
}

// Test case for nil triangle list
func testNilTriangleList(t *testing.T) {
	testDir := t.TempDir()
	nilTestPath := filepath.Join(testDir, "nil.stl")

	if err := WriteSTLBinary(nilTestPath, nil); err != nil {
		t.Fatalf("Failed to write STL with nil triangle list: %v", err)
	}

	stlFile, err := os.Open(nilTestPath)
	if err != nil {
		t.Fatalf("Cannot open generated STL file: %v", err)
	}
	defer func() {
		if err := stlFile.Close(); err != nil {
			t.Fatalf("Failed to close STL file: %v", err)
		}
	}()

	if _, err := stlFile.Seek(80, 0); err != nil {
		t.Fatalf("Failed to seek past header: %v", err)
	}
	verifyTriangleCount(t, stlFile, 0)
}

// Main test function
func TestWriteSTLBinary(t *testing.T) {
	t.Run("verify successful STL file writing", testBasicSTLGeneration)
	t.Run("handle invalid file path", testInvalidFilePath)
	t.Run("handle empty triangle list", testEmptyTriangleList)
	t.Run("handle nil triangle list", testNilTriangleList)
}
